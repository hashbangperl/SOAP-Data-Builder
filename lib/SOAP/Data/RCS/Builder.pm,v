head	1.8;
access;
symbols;
locks
	teejay:1.8; strict;
comment	@# @;


1.8
date	2004.10.23.09.04.40;	author teejay;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.18.42.30;	author teejay;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.08.16.31.22;	author teejay;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.24.16.13.15;	author teejay;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.19.10.53.23;	author teejay;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.15.02.51;	author teejay;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.14.59.46;	author teejay;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.12.14.08.05;	author teejay;	state Exp;
branches;
next	;


desc
@@


1.8
log
@fixed pod
removed warnings
@
text
@package SOAP::Data::Builder;

use SOAP::Data::Builder::Element;

# Copyright (c) 2003 Surrey Technologies, Ltd ( http://www.surreytech.co.uk )
# Copyright (c) 2004 Aaron Trevena

# This Module provides a quick and easy way to build complex SOAP data
# and header structures for use with SOAP::Lite.

# It primarily provides a wrapper around SOAP::Serializer and SOAP::Data
# (or SOAP::Header) enabling you to generate complex XML within your SOAP
# request or response.

=head1 NAME

  SOAP::Data::Builder - A wrapper simplifying SOAP::Data and SOAP::Serialiser

=head1 DESCRIPTION

  This Module provides a quick and easy way to build complex SOAP data
  and header structures for use with SOAP::Lite.

  It primarily provides a wrapper around SOAP::Serializer and SOAP::Data
  (or SOAP::Header) enabling you to generate complex XML within your SOAP
  request or response.

=head1 SYNOPSIS

  use SOAP::Lite ( +trace => 'all', maptype => {} );

  use SOAP::Data::Builder;

  # create new Builder object
  my $soap_data_builder = SOAP::Data::Builder->new();

  #<eb:MessageHeader eb:version="2.0" SOAP:mustUnderstand="1">
  $soap_data_builder->add_elem(name => 'eb:MessageHeader',
                             header=>1,
                               attributes => {"eb:version"=>"2.0", "SOAP::mustUnderstand"=>"1"});

  #   <eb:From>
  #        <eb:PartyId>uri:example.com</eb:PartyId>
  #        <eb:Role>http://rosettanet.org/roles/Buyer</eb:Role>
  #   </eb:From>
  my $from = $soap_data_builder->add_elem(name=>'eb:From',
                               parent=>$soap_data_builder->get_elem('eb:MessageHeader'));

  $soap_data_builder->add_elem(name=>'eb:PartyId',
                               parent=>$from,
                               value=>'uri:example.com');

  $from->add_elem(name=>'eb:Role', value=>'http://path.to/roles/foo');

  #   <eb:DuplicateElimination/>
  $soap_data_builder->add_elem(name=>'eb:DuplicateElimination', parent=>$soap_data_builder->get_elem('eb:MessageHeader'));


  # fetch Data
  my $data =  SOAP::Data->name('SOAP:ENV' =>
                             \SOAP::Data->value( $soap_data_builder->to_soap_data )
                              );

  # serialise Data using SOAP::Serializer
  my $serialized_xml = SOAP::Serializer->autotype(0)->serialize( $data );

  # serialise Data using wrapper
  my $wrapper_serialised_xml = $soap_data_builder->serialise();

  # make SOAP request with data

  my $foo  = SOAP::Lite
      -> uri('http://www.liverez.com/SoapDemo')
      -> proxy('http://www.liverez.com/soap.pl')
      -> getTest( $soap_data_builder->to_soap_data )
      -> result;

=cut

use SOAP::Lite ( maptype => {} );

use Data::Dumper;
use strict;

our $VERSION = "0.8";

=head1 METHODS

=head2 new(autotype=>0)

Constructor method for this class, it instantiates and returns the Builder object,
taking named options as parameters

my $builder = SOAP::Data::Builder->new( autotype=>0 ); # new object with no autotyping

supported options are :

* autotype which switches on/off SOAP::Serializers autotype setting

* readable which switches on/off SOAP::Serialixer readable setting

=cut

sub new {
    my ($class,%args) = @@_;

    my $self = { elements => [], };
    bless ($self,ref $class || $class);
    foreach my $key (keys %args) {
      $self->{options}{$key} = $args{$key};
    }

    return $self;
}

=head2 serialise()

Wrapper for SOAP::Serializer (sic), serialises the contents of the Builder object
and returns the XML as a string

# serialise Data using wrapper
my $wrapper_serialised_xml = $soap_data_builder->serialise();

This method does not accept any arguments

NOTE: serialise is spelt properly using the King's English

=cut

sub serialise {
  my $self = shift;
  my $data =  SOAP::Data->name('SOAP:ENV' =>
			       \SOAP::Data->value( $self->to_soap_data )
			      );
  my $serialized = SOAP::Serializer->autotype($self->autotype)->readable($self->readable)->serialize( $data );
}

=head2 autotype()

returns whether the object currently uses autotype when serialising

=cut

sub autotype {
  return shift->{options}{autotype} || 0;
}

=head2 readable()

returns whether the object currently uses readable when serialising

=cut

sub readable {
 return shift->{options}{readable} || 0;
}

=head2 to_soap_data()

  returns the contents of the object as a list of SOAP::Data and/or SOAP::Header objects

  NOTE: make sure you call this in array context!

=cut

sub to_soap_data {
    my $self = shift;
    my @@data = ();
    foreach my $elem ( $self->elems ) {
	push(@@data,$self->get_as_data($elem,1));
    }
    return @@data;
}

sub elems {
  my $self = shift;
  my @@elems = @@{$self->{elements}};
  return @@elems;
}

=head1 add_elem

This method adds an element to the structure, either to the root list
or a specified element.

optional parameters are : parent, value, attributes, header, isMethod

parent should be an element 'add_elem(parent=>$parent_element, .. );'

or the full name of an element 'add_elem(parent=>'name/of/parent', .. );'

value should be a string,

attributes should be a hashref : { 'ns:foo'=> bar, .. }

header should be 1 or 0 specifying whether the element should be built using SOAP::Data or SOAP::Header

returns the added element

my $bar_elem = $builder->add_elem(name=>'bar', value=>$foo->{bar}, parent=>$foo);

would produce SOAP::Data representing an XML fragment like '<foo><bar>..</bar></foo>'

=cut

sub add_elem {
  my ($self,%args) = @@_;
  my $elem = SOAP::Data::Builder::Element->new(%args);
  if ( $args{parent} ) {
      my $parent = $args{parent};
      unless (ref $parent eq 'SOAP::Data::Builder::Element') {
	  $parent = $self->get_elem($args{parent});
      }
      $parent->add_elem($elem);
  } else {
      push(@@{$self->{elements}},$elem);
  }
  return $elem;
}

=head2 get_elem('ns:elementName')

returns an element (which is an internal data structure rather than an object)

returns the first element with the name passed as an argument,
sub elements can be referred to as 'grandparent/parent/element'

This structure is passed to other object methods and may change in behaviour, 
type or structure without warning as the class is developed

=cut

sub get_elem {
    my ($self,$name) = (@@_,'');
    my ($a,$b);
    my @@keys = split (/\//,$name);
    foreach my $elem ( $self->elems) {
	if ($elem->name eq $keys[0]) {
	    $a = $elem;
	    $b = shift(@@keys);
	    last;
	}
    }

    my $elem = $a;
    $b = shift(@@keys);
    if ($b) {
	$elem = $self->find_elem($elem,$b,@@keys);
    }

    return $elem;
}

# internal method

sub find_elem {
    my ($self,$parent,$key,@@keys) = @@_;
    my ($a,$b);
    foreach my $elem ( $parent->get_children()) {
	next unless ref $elem;
	if ($elem->{name} eq $key) {
	    $a = $elem;
	    $b = $key;
	    last;
	}
    }

    my $elem = $a;
    undef($b);
    while ($b = shift(@@keys) ) {
	$elem = $self->find_elem($elem,$b,@@keys);
    }
    return $elem;
}


# internal method

sub get_as_data {
  my ($self,$elem) = @@_;
  my @@values;
  foreach my $value ( @@{$elem->value} ) {
    next unless ($value);
    if (ref $value) {
      push(@@values,$self->get_as_data($value))
    } else {
      push(@@values,$value);
    }
  }
  my @@data = ();

  if (ref $values[0]) {
    $data[0] = \SOAP::Data->value( @@values );
  } else {
    @@data = @@values;
  }
  if ($elem->{header}) {
    $data[0] = SOAP::Header->name($elem->{name} => $data[0])->attr($elem->attributes());
  } else {
      if ($elem->{isMethod}) {
	  @@data = ( SOAP::Data->name($elem->{name} )->attr($elem->attributes()) => SOAP::Data->value( @@values ) );
      } elsif ($elem->{type}) {
	  $data[0] = SOAP::Data->name($elem->{name} => $data[0])->attr($elem->attributes())->type($elem->{type});
      } else {
	  $data[0] = SOAP::Data->name($elem->{name} => $data[0])->attr($elem->attributes());
      }
  }
  return @@data;
}

=head2 EXPORT

None.

=head1 SEE ALSO

L<perl>

L<SOAP::Lite>

=head1 AUTHOR

Aaron Trevena, E<lt>teejay@@droogs.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2003 Surrey Technlogies, Ltd
Copyright (C) 2004 by Aaron Trevena

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself,

=cut


#############################################################################
#############################################################################

1;
@


1.7
log
@fixed and documented add_elem
@
text
@d6 1
d46 1
a46 1
  $soap_data_builder->add_elem(name=>'eb:From',
d50 1
a50 1
                               parent=>$soap_data_builder->get_elem('eb:MessageHeader/eb:From'),
d52 2
a53 3
  $soap_data_builder->add_elem(name=>'eb:Role',
                               parent=>$soap_data_builder->get_elem('eb:MessageHeader/eb:From'),
                               value=>'http://path.to/roles/foo');
a131 2
#  warn "serialise() called \n\n";
#  warn Dumper ($self->to_soap_data), "\n\n";
a167 1
#    warn "sub : to_soap_data called\n";
a169 1
#	warn "handling elem : ", $elem->name(), "\n";
a174 2
# internal method

a210 2
      warn "parent  : $parent\n";
      warn "ref for parent : ". ref $parent;
a214 2
      warn "added new sub elem ($args{name}) to elem " . $parent->{name} ;
      warn "dump : ", Dumper($parent), "\n";
a217 1
  warn "[Builder.pm] : returning elem : $elem\n";
a234 1
    warn "get_elem ($name)\n";
a236 1
    warn "have keys : ", join (', ',@@keys), "\n";
a237 1
	warn "handling elem : $elem->{name} - matching against $keys[0]\n";
a240 1
	    warn " found match : $elem->{name} / key : $b \n";
a244 2
    warn "still have keys : ", join (', ',@@keys), "\n";

a247 1
	warn "fetching with subkey $b\n";
a250 2
#    warn "returning element :\n", Dumper($elem), "\n";

a256 1
    warn "find_elem ..\n";
a258 3
    warn "have key : $key \n";
    warn "have keys : ", join (', ',@@keys), "\n";
    warn "parent : ", $parent->name, "\n";
a260 1
	warn "handling elem : $elem->{name} - matching against $key\n";
a263 1
	    warn " found match : $elem->{name} / key : $b \n";
a267 2
    warn "still have keys : ", join (', ',@@keys), "\n";

a270 1
	warn "fetching sub key $b\n";
a272 1
    warn "returning elem : $elem\n";
a280 1
#  warn "-- sub : get_as_data called with $elem->{name}\n";
a282 1
#    warn "-- -- value : $value ";
a284 1
#      warn " ..is ref\n";
a286 1
#      warn " ..is scalar\n";
d311 24
@


1.6
log
@CPAN version 0.7

adds support for element type and improved pod
@
text
@d85 1
a85 1
our $VERSION = "0.7";
d187 1
a187 1
=head1 add_elem(name=>'ns:Name')
d194 1
a194 1
parent should be an element fetched using get_elem
d196 3
a198 1
value should be a string, to add child nodes use add_elem(parent=>get_elem('name/of/parent'), .. )
d204 6
a213 4
  if (ref $args{parent}) {
      $args{parent} = $args{parent}->fullname();
#      warn "adding $args{name} to $args{parent}\n";
  }
d216 9
a224 3
      $self->get_elem($args{parent})->add_elem($elem);
#      warn "added new sub elem ($args{name}) to elem ($args{parent})\n";
      #    warn "dump : ", Dumper($args{parent}), "\n";
d228 1
d245 13
a257 12
  my ($self,$name) = (@@_,'');
#  warn "get_elem ($name)\n";
  my ($a,$b);
  my @@keys = split (/\//,$name);
#  warn "have keys : ", join (', ',@@keys), "\n";
  foreach my $elem ( $self->elems) {
#    warn "handling elem : $elem->{name} - matching against $keys[0]\n";
    if ($elem->name eq $keys[0]) {
      $a = $elem;
      $b = shift(@@keys);
#      warn " found match : $elem->{name} / key : $b \n";
      last;
a258 1
  }
d260 1
a260 1
#  warn "still have keys : ", join (', ',@@keys), "\n";
d262 6
a267 5
  my $elem = $a;
  while ($b = shift(@@keys) ) {
#    warn "fetching with subkey $b\n";
    $elem = $self->find_elem($elem,$b,@@keys);
  }
d269 1
a269 1
#  warn "returning element :\n", Dumper($elem), "\n";
d271 1
a271 1
  return $elem;
d277 15
a291 14
#  warn "find_elem ..\n";
  my ($self,$parent,$key,@@keys) = @@_;
  my ($a,$b);
#  warn "have key : $key \n";
#  warn "have keys : ", join (', ',@@keys), "\n";
#  warn "parent : ", $parent->name, "\n";
  foreach my $elem ( $parent->get_children()) {
    next unless ref $elem;
#    warn "handling elem : $elem->{name} - matching against $key\n";
    if ($elem->{name} eq $key) {
      $a = $elem;
      $b = $key;
#      warn " found match : $elem->{name} / key : $b \n";
      last;
a292 1
  }
d294 1
a294 1
#  warn "still have keys : ", join (', ',@@keys), "\n";
d296 8
a303 6
  my $elem = $a;
  while ($b = shift(@@keys) ) {
#    warn "fetching sub key $b\n";
    $elem = $self->find_elem($elem,$b,@@keys);
  }
  return $elem;
@


1.5
log
@made to work with the Element Class to handle elements instead of
simple hashrefs
@
text
@d29 1
a29 1
use SOAP::Lite ( +trace => 'all', maptype => {} );
d31 1
a31 1
use SOAP::Data::Builder;
d33 2
a34 2
# create new Builder object
my $soap_data_builder = SOAP::Data::Builder->new();
d36 21
a56 22
#<eb:MessageHeader eb:version="2.0" SOAP:mustUnderstand="1">
$soap_data_builder->add_elem(name => 'eb:MessageHeader', header=>1, attributes => {"eb:version"=>"2.0", "SOAP::mustUnderstand"=>"1"});

#   <eb:From>
#        <eb:PartyId>uri:example.com</eb:PartyId>
#        <eb:Role>http://rosettanet.org/roles/Buyer</eb:Role>
#   </eb:From>
$soap_data_builder->add_elem(name=>'eb:From', parent=>$soap_data_builder->get_elem('eb:MessageHeader'));
$soap_data_builder->add_elem(name=>'eb:PartyId', parent=>$soap_data_builder->get_elem('eb:MessageHeader/eb:From'), 
                             value=>'uri:example.com');
$soap_data_builder->add_elem(name=>'eb:Role',
                             parent=>$soap_data_builder->get_elem('eb:MessageHeader/eb:From'), 
                             value=>'http://path.to/roles/foo');

#   <eb:DuplicateElimination/>
$soap_data_builder->add_elem(name=>'eb:DuplicateElimination', parent=>$soap_data_builder->get_elem('eb:MessageHeader'));


# fetch Data
my $data =  SOAP::Data->name('SOAP:ENV' =>
			     \SOAP::Data->value( $soap_data_builder->to_soap_data )
			      );
a57 2
# serialise Data using SOAP::Serializer
my $serialized_xml = SOAP::Serializer->autotype(0)->serialize( $data );
d59 4
a62 2
# serialise Data using wrapper
my $wrapper_serialised_xml = $soap_data_builder->serialise();
d64 2
a65 1
# make SOAP request with data
d67 2
a68 5
my $foo  = SOAP::Lite
    -> uri('http://www.liverez.com/SoapDemo')
    -> proxy('http://www.liverez.com/soap.pl')
    -> getTest( $soap_data_builder->to_soap_data )
    -> result;
d70 7
d80 1
a80 1
use SOAP::Lite ( +trace => 'all', maptype => {} );
d85 1
a85 1
our $VERSION = "0.3";
d96 5
a100 1
supported options are autotype which switches on/off SOAP::Serializers autotype
d132 2
a133 2
  warn "serialise() called \n\n";
  warn Dumper ($self->to_soap_data), "\n\n";
d137 1
a137 1
  my $serialized = SOAP::Serializer->autotype($self->autotype)->serialize( $data );
d150 10
d170 1
a170 1
    warn "sub : to_soap_data called\n";
d173 1
a173 1
	warn "handling elem : ", $elem->name(), "\n";
d208 1
d213 1
a213 1
      warn "added new sub elem ($args{name}) to elem ($args{parent})\n";
d235 1
a235 1
  warn "get_elem ($name)\n";
d238 1
a238 1
  warn "have keys : ", join (', ',@@keys), "\n";
d240 1
a240 1
    warn "handling elem : $elem->{name} - matching against $keys[0]\n";
d244 1
a244 1
      warn " found match : $elem->{name} / key : $b \n";
d249 1
a249 1
  warn "still have keys : ", join (', ',@@keys), "\n";
d253 1
a253 1
    warn "fetching with subkey $b\n";
d265 1
a265 1
  warn "find_elem ..\n";
d268 3
a270 3
  warn "have key : $key \n";
  warn "have keys : ", join (', ',@@keys), "\n";
  warn "parent : ", $parent->name, "\n";
d297 1
a297 1
  warn "-- sub : get_as_data called with $elem->{name}\n";
d300 2
a301 1
    warn "-- -- value : $value ";
d303 1
a303 1
      warn " ..is ref\n";
d306 1
a306 1
      warn " ..is scalar\n";
d320 7
a326 5
    if ($elem->{isMethod}) {
      @@data = ( SOAP::Data->name($elem->{name} )->attr($elem->attributes()) => SOAP::Data->value( @@values ) );
    } else {
      $data[0] = SOAP::Data->name($elem->{name} => $data[0])->attr($elem->attributes());
    }
@


1.4
log
@seems to work properly in call now
@
text
@d3 2
d22 1
a22 1
 
d81 1
a81 1
our $VERSION = "0.1";
d124 2
d151 8
a158 7
  my $self = shift;
  warn "sub : to_soap_data called\n";
  my @@data = ();
  foreach my $elem ( $self->elems ) {
    push(@@data,$self->get_as_data($elem,1));
  }
  return @@data;
d174 1
a174 1
optional parameters are : parent, value, attributes, header, isEntity
d188 4
a191 9
  my $elem = {
	      name => $args{name},
	      attr => {},
	      value => [ ],
	     };
  $elem->{isMethod} = $args{isMethod} || 0;
  $elem->{header} = $args{header} || 0;
  $elem->{attr} = $args{attributes}, if ( $args{attributes}, );
  $elem->{value} = [ $args{value} ] if ( $args{value} );
d193 3
a195 3
    push(@@{$args{parent}{value}},$elem);
    warn "added new sub elem ($args{name}) to elem ($args{parent}{name})\n";
#    warn "dump : ", Dumper($args{parent}), "\n";
d197 1
a197 1
    push(@@{$self->{elements}},$elem);
d199 1
d221 2
a222 2
#    warn "handling elem : $elem->{name} - matching against $keys[0]\n";
    if ($elem->{name} eq $keys[0]) {
d225 1
a225 1
#      warn " found match : $elem->{name} / key : $b \n";
d230 1
a230 1
#  warn "still have keys : ", join (', ',@@keys), "\n";
d234 1
a234 1
#    warn "fetching with subkey $b\n";
d250 3
a252 3
#  warn "have keys : ", join (', ',@@keys), "\n";
#  warn "parent : ", Dumper( $parent ), "\n";
  foreach my $elem ( @@{$parent->{value}}) {
d273 1
d278 1
a278 1
  warn "-- sub : get_as_data called with $elem->{name}\n"; 
d280 1
a280 1
  foreach my $value ( @@{$elem->{value}} ) {
a289 1

a291 4
  warn "\n##################\n values : \n ";
  warn Dumper(@@values);
  warn "\n##################\n ";

a296 1

d298 1
a298 1
    $data[0] = SOAP::Header->name($elem->{name} => $data[0])->attr($elem->{attr});
d301 1
a301 1
      @@data = ( SOAP::Data->name($elem->{name} )->attr($elem->{attr}) => SOAP::Data->value( @@values ) );
d303 1
a303 1
      $data[0] = SOAP::Data->name($elem->{name} => $data[0])->attr($elem->{attr});
a305 1

@


1.3
log
@small fix to make top level elements work a bit better when 'call'ed
@
text
@d42 2
a43 1
$soap_data_builder->add_elem(name=>'eb:PartyId', parent=>$soap_data_builder->get_elem('eb:MessageHeader/eb:From'), value=>'uri:example.com');
d169 1
a169 1
optional parameters are : parent, value, attributes, header
d188 1
d275 1
a275 1
  my ($self,$elem,$top) = @@_;
d304 2
a305 2
    if ($top) {
      @@data = ( SOAP::Data->name($elem->{name} )->attr($elem->{attr}) => $data[0] );
@


1.2
log
@changed to work with call()
@
text
@d150 1
a150 1
    push(@@data,$self->get_as_data($elem));
@


1.1
log
@Initial revision
@
text
@d78 2
d147 1
d212 2
a213 2
  warn "get_elem\n";
  my ($self,$name) = @@_;
d218 1
a218 1
    warn "handling elem : $elem->{name} - matching against $keys[0]\n";
d222 1
a222 1
      warn " found match : $elem->{name} / key : $b \n";
d227 1
a227 1
  warn "still have keys : ", join (', ',@@keys), "\n";
d231 1
a231 1
    warn "fetching with subkey $b\n";
d235 1
a235 1
  warn "returning element :\n", Dumper($elem), "\n";
d247 2
a248 2
  warn "have keys : ", join (', ',@@keys), "\n";
  warn "parent : ", Dumper( $parent ), "\n";
d251 1
a251 1
    warn "handling elem : $elem->{name} - matching against $key\n";
d255 1
a255 1
      warn " found match : $elem->{name} / key : $b \n";
d260 1
a260 1
  warn "still have keys : ", join (', ',@@keys), "\n";
d264 1
a264 1
    warn "fetching sub key $b\n";
d273 2
a274 1
  my ($self,$elem) = @@_;
d277 1
d279 1
d282 1
d287 5
a291 1
  my $data;
d294 1
a294 1
    $data = \SOAP::Data->value( @@values );
d296 1
a296 1
    $data = "$values[0]";
d300 1
a300 1
    $data = SOAP::Header->name($elem->{name} => $data)->attr($elem->{attr});
d302 5
a306 1
    $data = SOAP::Data->name($elem->{name} => $data)->attr($elem->{attr});
d309 1
a309 1
  return $data;
d313 2
a314 1

@
